//
//  RichCluster.cpp
//  RichCluster
//
//  Created by Sarah on 6/2/25.
//

#include <stdio.h>
#include <string>
#include "RichCluster.h"
#include "StringUtils.h"

void RichCluster::computeDistances() {
  int totalGeneCount = StringUtils::countUniqueElements(geneIDs);
  
  for (int i=0; i<n_terms; ++i) {
    // the unordered set of term1 genes
    std::unordered_set<std::string> term1_genes = StringUtils::splitStringToUnorderedSet(geneIDs[i], ",");
    
    for (int j=0; j<n_terms; ++j) {
      if (i == j) {
        distMatrix.setDistance(RichCluster::SAME_TERM_DISTANCE, i, j);
        continue;
      }
      // unordered set of term2 genes
      std::unordered_set<std::string> term2_genes = StringUtils::splitStringToUnorderedSet(geneIDs[j], ",");
      
      double distanceScore = dm.computeDistance(term1_genes, term2_genes, totalGeneCount);
      distMatrix.setDistance(distanceScore, i, j);
      
      // if term similarity is ABOVE the threshold
      if (distanceScore >= dm.getCutoff()) {
        // add to adjacency list bidirectionally
        adjList.addNeighbor(i, j);
        adjList.addNeighbor(j, i);
      }
    }
  }
}

void RichCluster::filterSeeds() {
  for (const auto& [node, neighbors] : RichCluster::adjList.getAdjList()) {
    std::unordered_set<int> cluster = filterSeed(node, neighbors);
    clusList.addCluster(cluster);
  }
}

std::unordered_set<int> RichCluster::filterSeed(
    int node, std::unordered_set<int> neighbors
) {
  std::unordered_set<int> cluster{node};
  while (true) {
    int bestN = -1;
    double bestLink = -1.0;
    
    for (int n : neighbors) {
      if (cluster.count(n)) continue;
      std::unordered_set<int> n_set{n};
      double link = lm.computeLinkage(cluster, n_set);
      if (link > bestLink) {
        bestLink = link;
        bestN = n;
      }
    }
    if (bestLink < lm.getCutoff() || bestN == -1)
      break;
    cluster.insert(bestN);
  }
  return cluster;
}
